swap : (A B C : U 0) -> (A -> B -> C) -> (B -> A -> C)
    := \A B C g. \b a. g a b

subst : (A : U 0) -> (P : A -> U 0) -> (a b : A) -> a = b @ A -> P a -> P b
    := \A P a b e. J A a {0} (\x _. P a -> P x) (\pa. pa) b e

subst1 : (A : U 0) -> (P : A -> U 1) -> (a b : A) -> a = b @ A -> P a -> P b
    := \A P a b e. J A a {1} (\x _. P a -> P x) (\pa. pa) b e

sym : (A : U 0) -> (a b : A) -> a = b @ A -> b = a @ A
   := \A a b e. subst A (\x. x = a @ A) a b e refl

------------------------------------------------------------

recProd : (A B C : U 0) -> (A -> B -> C) -> (A * B) -> C
    := \A B C g p. g p.1 p.2

uppt : (A B : U 0) -> (p : A * B) -> (p.1, p.2) = p @ (A * B)
    := \A B p. refl

indProd 
    : (A B : U 0) 
   -> (C : A * B -> U 0) 
   -> ((x : A) -> (y : B) -> C (x, y)) 
   -> ((p : A * B) -> C p)
   := \A B C g p. g p.1 p.2

pairEq : 
    (A B : U 0) 
 -> (p q : A * B) 
 -> p.1 = q.1 @ A 
 -> p.2 = q.2 @ B 
 -> p = q @ (A * B)
    := \A B p q e e'. 
         let hyp  : p = (q.1, p.2) @ (A * B) := subst A (\x. p = (x, p.2) @ (A * B)) p.1 q.1 e  refl in
         let hyp' : p = (q.1, q.2) @ (A * B) := subst B (\x. p = (q.1, x) @ (A * B)) p.2 q.2 e' hyp  in
         subst (A * B) (\x. p = x @ (A * B)) (q.1, q.2) q refl hyp'

ac :
    (A B : U 0)
 -> (R : A -> B -> U 0)
 -> ((x : A) -> (y : B) * R x y)
 -> ((f : A -> B) * (x : A) -> R x (f x))
 := \A B R g.
    (\x. (g x).1, \x. (g x).2) -- (f : A -> B) * (x : A) -> R x (f x) | f := \x. (g x).1
                               -- (x : A) -> R x (g x).1
			       
         	 	       -- (y : B) * R x y | y := (g x).1
			       -- R x (g x).1
------------------------------------------------------------

Void : U 0 := Z = S Z @ Nat

------------------------------------------------------------

singl : (A : U 0) -> (a : A) -> U 0
    := \A a. (x : A) * (a = x @ A)

Jsingl :
     (A : U 0)
     (a : A)
  -> (P : singl A a -> U 0)
  -> P (a, refl)
  -> ((q : singl A a) -> P q)
  := \A a P r q. J A a {0} (\x e. P (x, e)) r q.1 q.2

------------------------------------------------------------

Unit : U 0  := singl Nat Z
star : Unit := (Z, refl)

unitEq : (u : Unit) -> u = star @ Unit
       := \u. J Nat Z {0} (\x p. (x, p) = star @ Unit) refl u.1 u.2

------------------------------------------------------------

isZero : Nat -> U 0
       := \n. ind {1} (\_. U 0) Unit (\_ _. Void) n

isBool : Nat -> U 0
       := \n. ind {1} (\_. U 0) Unit (\k _. isZero k) n

Bool  : U 0  := (n : Nat) * isBool n
true  : Bool := (Z,   star)
false : Bool := (S Z, star)

boolInd :
    (P : Bool -> U 0)
 -> P true
 -> P false
 -> (b : Bool) -> P b
 := \P pt pf b. 
    ind {0}
    	-- motive
    	(\n. (h : isBool n) -> P (n, h))
	-- 0 => True
    	(\h. let e  : h = star @ Unit := unitEq h in
	     let e' : star = h @ Unit := sym Unit h star e in
	     subst Unit (\u. P (Z, u)) star h e' pt)
	-- k + 1
	(\k _. ind {0} (\x. (hx : isZero x) -> P (S x, hx))
		       -- hx : Unit
	       	       -- P (S Z, star)
	       	       (\hx. let e  : hx = star @ Unit := unitEq hx in
		             let e' : star = hx @ Unit := sym Unit hx star e in
			     subst Unit (\u. P (S Z, u)) star hx e' pf)
	       	       -- hx : Void			     
	       	       -- P (S (S k'), hx)
	       	       (\k' _ hx. contra hx)
	       	       k)
	b.1
	b.2

boolInd1 :
    (P : Bool -> U 1)
 -> P true
 -> P false
 -> (b : Bool) -> P b
 := \P pt pf b. 
    ind {1}
        (\n. (h : isBool n) -> P (n, h))
        (\h. let e  : h = star @ Unit := unitEq h in
             let e' : star = h @ Unit := sym Unit h star e in
             subst1 Unit (\u. P (Z, u)) star h e' pt)
    (\k _. ind {1} (\x. (hx : isZero x) -> P (S x, hx))
               (\hx. let e  : hx = star @ Unit := unitEq hx in
                     let e' : star = hx @ Unit := sym Unit hx star e in
                     subst1 Unit (\u. P (S Z, u)) star hx e' pf)
               (\k' _ hx. contra hx)
               k)
    b.1
    b.2

ifU : (A B : U 0) -> Bool -> U 0
    := \A B. boolInd1 (\_. U 0) A B

if : (A B : U 0) -> A -> B -> (b : Bool) -> ifU A B b
   := \A B. boolInd (ifU A B)

------------------------------------------------------------

Coprod : (A B : U 0) -> U 0 := \A B. (b : Bool) * ifU A B b
inl    : (A B : U 0) -> A -> Coprod A B := \A B a. (true,  a)
inr    : (A B : U 0) -> B -> Coprod A B := \A B b. (false, b)

coprodInd :
     (A B : U 0)
  -> (P : Coprod A B -> U 0)
  -> ((a : A) -> P (inl A B a))
  -> ((b : B) -> P (inr A B b))
  -> ((x : Coprod A B) -> P x)
  := \A B P l r x.
     boolInd (\b. (v : ifU A B b) -> P (b, v)) l r x.1 x.2
	