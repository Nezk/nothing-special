 swap : (A B C : U 0) -> (A -> B -> C) -> (B -> A -> C)
    := \A B C g. \b a. g a b

id : (A : U 0) -> (A -> A)
    := \A a. a

comp : (A B C : U 0) -> (B -> C) -> (A -> B) -> (A -> C)
    := \A B C g f a. g (f a)

subst : (A : U 0) -> (P : A -> U 0) -> (a b : A) -> a = b @ A -> P a -> P b
    := \A P a b e. J A a {0} (\x _. P a -> P x) (\pa. pa) b e

subst1 : (A : U 0) -> (P : A -> U 1) -> (a b : A) -> a = b @ A -> P a -> P b
    := \A P a b e. J A a {1} (\x _. P a -> P x) (\pa. pa) b e

substU :
    (P : U 0 -> U 0)
 -> (A B : U 0)
 -> A = B @ U 0
 -> P A
 -> P B
 := \P A B e x.
    J (U 0) A {0} (\X _. P X) x B e

sym : (A : U 0) -> (a b : A) -> a = b @ A -> b = a @ A
   := \A a b e. subst A (\x. x = a @ A) a b e refl

ap :
      (A B : U 0)
   -> (a b : A)
   -> (f : A -> B)
   -> a = b @ A
   -> (f a) = (f b) @ B
   := \A B a b f e.
      subst A (\x. f a = f x @ B) a b e refl

trans :
      (A : U 0)
   -> (a b c : A)
   -> a = b @ A
   -> b = c @ A
   -> a = c @ A
   := \A a b c e e'.
      subst A (\x. a = x @ A) b c e' e

transRight :
      (A : U 0)
   -> (x y : A)
   -> (p : x = y @ A)
   -> trans A x y y p refl = p @ (x = y @ A)
   := \A x y p. refl

transLeft :
      (A : U 0)
   -> (x y : A)
   -> (p : x = y @ A)
   -> trans A x x y refl p = p @ (x = y @ A)
   := \A x y e.
      J A x {0} (\y' e'. trans A x x y' refl e' = e' @ (x = y' @ A)) refl y e

invRight :
       (A : U 0)
    -> (x y : A)
    -> (p : x = y @ A)
    -> trans A x y x p (sym A x y p) = refl @ (x = x @ A)
    := \A x y p.
       J A x {0}
         (\y' p'. trans A x y' x p' (sym A x y' p') = refl @ (x = x @ A))
	 refl
	 y
	 p

total : (Base : U 0) -> (F : Base -> U 0) -> U 0
    := \Base F. (b : Base) * F b

pathLift :
    (Base : U 0)
 -> (F : Base -> U 0)
 -> (x y : Base)
 -> (u : F x)
 -> (p : x = y @ Base)
 -> (x, u) = (y, subst Base F x y p u) @ total Base F
 := \Base F x y u p.
    J Base x {0} (\y' p'. (x, u) = (y', subst Base F x y' p' u) @ total Base F)
      refl
      y
      p

substTrans :
    (A : U 0)
 -> (P : A -> U 0)
 -> (x y z : A)
 -> (p : x = y @ A)
 -> (q : y = z @ A)
 -> (u : P x)
 -> subst A P x z (trans A x y z p q) u
  = subst A P y z q (subst A P x y p u)
  @ (P z)
  := \A P x y z p q u.
     J A y {0}
       (\z' q'. subst A P x z' (trans A x y z' p q') u
              = subst A P y z' q'                    (subst A P x y p u) @ (P z'))
       refl
       z
       q

apd : (A : U 0)
   -> (P : A -> U 0)
   -> (f : (x : A) -> P x)
   -> (a b : A)
   -> (p : a = b @ A)
   -> subst A P a b p (f a) = f b @ (P b)
   := \A P f a b p.
      J A a {0} (\b' p'. subst A P a b' p' (f a) = f b' @ (P b'))
      refl
      b
      p

htpy : (A B : U 0) -> (f g : A -> B) -> U 0
     := \A B f g. (x : A) -> f x = g x @ B

{-
      f(x) ~ ap f(p) ~ f(y)
       |                 |
      H(x)             H(y)
       |                 |
      g(x) ~ ap g(p) ~ g(y)
-}
htpyNatural :
    (A B : U 0)
 -> (f g : A -> B)
 -> (H : htpy A B f g)
 -> (x y : A)
 -> (p : x = y @ A)
 -> trans B (f x) (g x) (g y) (H x) (ap A B x y g p) =
    trans B (f x) (f y) (g y) (ap A B x y f p) (H y)
    @ (f x = g y @ B)
 := \A B f g H x y p.
    J A x {0} (\y' p'. trans B (f x) (g x)  (g y') (H x)  (ap A B x y' g p') =
      	      	       trans B (f x) (f y') (g y') (ap A B x y' f p') (H y')
                       @ (f x = g y' @ B))
    -- H x = trans B (f x) (f x) (g x) refl (H x)
    (sym (f x = g x @ B)
    (trans B (f x) (f x) (g x) refl (H x))
    (H x)
    (transLeft B (f x) (g x) (H x)))
    y
    p

qinv : (A B : U 0) -> (A -> B) -> U 0
    := \A B f.
       (g : B -> A)
     * (htpy A A (comp A B A g f) (id A))
     * (htpy B B (comp B A B f g) (id B))

idQinv : (A : U 0) -> qinv A A (id A)
    := \A. (id A, \x. refl, \x. refl)

idtoeqv :
    (A B : U 0)
 -> (e : A = B @ U 0)
 -> qinv A B (substU (\X. A -> X) A B e (id A))
 := \A B e.
    J (U 0) A {0}
      (\B' p. qinv A B' (substU (\X'. A -> X') A B' p (id A)))
      (idQinv A)
      B
      e

concatEquiv :
    (A : U 0)
 -> (x y z : A)
 -> (p : x = y @ A)
 -> qinv (y = z @ A) (x = z @ A) (trans A x y z p)
 := \A x y z p.
    J A x {0} (\y' p'. qinv (y' = z @ A) (x = z @ A) (trans A x y' z p'))
      (\e. e,
       \h. transLeft A x z h,
       \h. transLeft A x z h)
      y
      p

------------------------------------------------------------

apS :
     (n k : Nat)
  -> n = k @ Nat
  -> (S n) = (S k) @ Nat
  := \n k e. ap Nat Nat n k (\x. S x) e

recNat :
     (C : U 0)
  -> C
  -> (Nat {- prev -} -> C {- res -} -> C)
  -> (Nat -> C)
  := \C fz fs n. ind {0} (\_. C) fz fs n

recNat1 :
     (C : U 1)
  -> C
  -> (Nat -> C -> C)
  -> (Nat -> C)
  := \C fz fs n. ind {1} (\_. C) fz fs n

double : Nat -> Nat
    := recNat Nat Z (\_ prev. S (S prev))

add : Nat -> Nat -> Nat
    := recNat (Nat -> Nat) (\n. n) (\_ addk n. S (addk n))

addAssoc : (i j k : Nat) -> add i (add j k) = add (add i j) k @ Nat
    := \i j k.
       ind {0} (\x. add x (add j k) = add (add x j) k @ Nat)
       	       refl
	       (\i' prev. ap Nat Nat (add i' (add j k)) (add (add i' j) k) (\n. S n) prev)
	       i

addZ : (k : Nat) -> add Z k = add k Z @ Nat
  := \k.
     ind {0} (\x. add Z x = add x Z @ Nat)
             refl
	     -- k'   = add k' Z
	     -- S k' = S (add k' Z)
	     (\k' prev. apS k' (add k' Z) prev)
	     k

addS : (n k : Nat) -> S (add n k) = add n (S k) @ Nat
  := \n k.
     ind {0} (\x. S (add x k) = add x (S k) @ Nat)
     refl
     (\k' prev. apS (S (add k' k)) (add k' (S k)) prev)
     n

addComm : (n k : Nat) -> add n k = add k n @ Nat
  := \n k.
     ind {0} (\x. add x k = add k x @ Nat)
     	     (addZ k)
	     (\k' h.
	       let e  := apS  (add k' k) (add k k') h in
	       let e' := addS k          k'           in
	       trans Nat (S (add k' k)) (S (add k k')) (add k (S k')) e e')
	     n

ack : Nat -> Nat -> Nat
    := \n.
       recNat (Nat -> Nat)
       	      (\m. S m)
	      (\n' ackn'. recNat Nat
	      	   	 	(ackn' (S Z))
				(\m' acn'm'. ackn' acn'm'))
	      n


------------------------------------------------------------

recProd : (A B C : U 0) -> (A -> B -> C) -> (A * B) -> C
    := \A B C g p. g p.1 p.2

uppt : (A B : U 0) -> (p : A * B) -> (p.1, p.2) = p @ (A * B)
    := \A B p. refl

indProd
    : (A B : U 0)
   -> (C : A * B -> U 0)
   -> ((x : A) -> (y : B) -> C (x, y))
   -> ((p : A * B) -> C p)
   := \A B C g p. g p.1 p.2

pairEq :
    (A B : U 0)
 -> (u u' : A)
 -> (v v' : B)
 -> (p : u = u' @ A)
 -> (q : v = v' @ B)
 -> (u, v) = (u', v') @ (A * B)
 := \A B u u' v v' p q.
     subst A (\x. (u, v) = (x, v') @ (A * B)) u u' p
    (subst B (\x. (u, v) = (u, x)  @ (A * B)) v v' q refl)

ac :
    (A B : U 0)
 -> (R : A -> B -> U 0)
 -> ((x : A) -> (y : B) * R x y)
 -> ((f : A -> B) * (x : A) -> R x (f x))
 := \A B R g.
    (\x. (g x).1, \x. (g x).2) -- (f : A -> B) * (x : A) -> R x (f x) | f := \x. (g x).1
                               -- (x : A) -> R x (g x).1

         	 	       -- (y : B) * R x y | y := (g x).1
			       -- R x (g x).1
------------------------------------------------------------

Void : U 0 := Z = S Z @ Nat

Not : U 0 -> U 0
    := \A. A -> Void

NotNotNot : (A : U 0) -> Not (Not (Not A)) -> Not A
    := \A p a. p (\f. f a)

------------------------------------------------------------

singl : (A : U 0) -> (a : A) -> U 0
    := \A a. (x : A) * (a = x @ A)

Jsingl :
     (A : U 0)
     (a : A)
  -> (P : singl A a -> U 0)
  -> P (a, refl)
  -> ((q : singl A a) -> P q)
  := \A a P r q. J A a {0} (\x e. P (x, e)) r q.1 q.2

------------------------------------------------------------

Unit : U 0  := singl Nat Z
star : Unit := (Z, refl)

unitEq : (u : Unit) -> u = star @ Unit
       := \u. J Nat Z {0} (\x p. (x, p) = star @ Unit) refl u.1 u.2

------------------------------------------------------------

isZero : Nat -> U 0
       := recNat1 (U 0) Unit (\_ _. Void)

isBool : Nat -> U 0
       := recNat1 (U 0) Unit (\k _. isZero k)

Bool  : U 0  := (n : Nat) * isBool n
true  : Bool := (Z,   star)
false : Bool := (S Z, star)

boolInd :
    (P : Bool -> U 0)
 -> P true
 -> P false
 -> (b : Bool) -> P b
 := \P pt pf b.
    ind {0}
    	-- motive
    	(\n. (h : isBool n) -> P (n, h))
	-- 0 => True
    	(\h. let e  := unitEq h in
	     let e' := sym Unit h star e in
	     subst Unit (\u. P (Z, u)) star h e' pt)
	-- k + 1
	(\k _. ind {0} (\x. (hx : isZero x) -> P (S x, hx))
		       -- hx : Unit
	       	       -- P (S Z, star)
	       	       (\hx. let e  := unitEq hx in
		             let e' := sym Unit hx star e in
			     subst Unit (\u. P (S Z, u)) star hx e' pf)
	       	       -- hx : Void
	       	       -- P (S (S k'), hx)
	       	       (\k' _ hx. contra hx)
	       	       k)
	b.1
	b.2

boolInd1 :
    (P : Bool -> U 1)
 -> P true
 -> P false
 -> (b : Bool) -> P b
 := \P pt pf b.
    ind {1}
        (\n. (h : isBool n) -> P (n, h))
        (\h. let e  := unitEq h in
             let e' := sym Unit h star e in
             subst1 Unit (\u. P (Z, u)) star h e' pt)
    (\k _. ind {1} (\x. (hx : isZero x) -> P (S x, hx))
               (\hx. let e  := unitEq hx in
                     let e' := sym Unit hx star e in
                     subst1 Unit (\u. P (S Z, u)) star hx e' pf)
               (\k' _ hx. contra hx)
               k)
    b.1
    b.2

ifU : (A B : U 0) -> Bool -> U 0
    := \A B. boolInd1 (\_. U 0) A B

if : (A B : U 0) -> A -> B -> (b : Bool) -> ifU A B b
   := \A B. boolInd (ifU A B)

------------------------------------------------------------

Coprod : (A B : U 0) -> U 0 := \A B. (b : Bool) * ifU A B b
inl    : (A B : U 0) -> A -> Coprod A B := \A B a. (true,  a)
inr    : (A B : U 0) -> B -> Coprod A B := \A B b. (false, b)

coprodInd :
     (A B : U 0)
  -> (P : Coprod A B -> U 0)
  -> ((a : A) -> P (inl A B a))
  -> ((b : B) -> P (inr A B b))
  -> ((x : Coprod A B) -> P x)
  := \A B P l r x.
     boolInd (\b. (v : ifU A B b) -> P (b, v)) l r x.1 x.2

------------------------------------------------------------

idNat : Nat -> Nat
    := \n. ind {0} (\_. Nat) Z (\_ r. S r) n

idNat' : Nat -> Nat
    := \n. ind {0} (\_. Nat) Z (\_ r. S r) n

test : idNat = idNat' @ (Nat -> Nat)
     := refl

test2 : Nat
      := let id' : Nat -> Nat := \n. n in
      	 id' Z

test3 : Nat
      := let z : Nat := Z in z

test4 : Nat

test5 : Nat
    := add (S (S (S Z))) (idNat test4)